import{_ as s,H as o,c as i,o as c,j as a,aN as n,a as t,p as d,s as m}from"./chunks/framework.DogoNsEl.js";const T=JSON.parse('{"title":"树和森林","description":"完整的安装,配置docker确保服务器能够正常的使用docker","frontmatter":{"title":"树和森林","date":"2025-03-07T01:16:28.000Z","permalink":"/articles/server/c/ds/treeex","categories":["底层开发"],"tags":["数据结构"],"titleTag":"基础","sidebar":true,"article":true,"comment":true,"description":"完整的安装,配置docker确保服务器能够正常的使用docker","coverImg":"https://github.com/matrix-johnjohn/kimo-docs/blob/main/images/articles/server/docker/00docker.png?raw=true","docAnalysis":true,"inCatalogue":true,"autoTitle":true,"articleUpdate":true,"inHomePost":true},"headers":[],"relativePath":"articles/server/c/29.treeex.md","filePath":"articles/server/c/29.treeex.md"}'),h={name:"articles/server/c/29.treeex.md"},l={id:"树和森林-基础",tabindex:"-1"};function u(p,e,g,k,b,x){const r=o("TkTitleTag");return c(),i("div",null,[a("h1",l,[e[1]||(e[1]=t("树和森林 ",-1)),d(r,{size:"large"},{default:m(()=>[...e[0]||(e[0]=[t("基础",-1)])]),_:1}),e[2]||(e[2]=t()),e[3]||(e[3]=a("a",{class:"header-anchor",href:"#树和森林-基础","aria-label":'Permalink to "树和森林 <TkTitleTag size="large">基础</TkTitleTag>"'},"​",-1))]),e[4]||(e[4]=n('<h2 id="树的存储结构" tabindex="-1">树的存储结构 <a class="header-anchor" href="#树的存储结构" aria-label="Permalink to &quot;树的存储结构&quot;">​</a></h2><blockquote><p>在大量的应用中,人们曾多次使用多种形式的存储结构来表示树;这里介绍三种常用的表示方法;</p></blockquote><h3 id="双亲表示法" tabindex="-1">双亲表示法 <a class="header-anchor" href="#双亲表示法" aria-label="Permalink to &quot;双亲表示法&quot;">​</a></h3><p>这种表示方法中,以一组连续的存储单元存储树的结点,每个结点除了数据域data外,还附设了一个parent域以指示其双亲结点的位置; <img src="https://raw.githubusercontent.com/matrix-johnjohn/kimo-docs/refs/heads/main/images/articles/server/c/data-struct/tree/06.tree.png" alt=""></p><h3 id="孩子表示法" tabindex="-1">孩子表示法 <a class="header-anchor" href="#孩子表示法" aria-label="Permalink to &quot;孩子表示法&quot;">​</a></h3><p>将每个结点的孩子排列起来,看成一个线性表,且以单链表作为存储结构; <img src="https://raw.githubusercontent.com/matrix-johnjohn/kimo-docs/refs/heads/main/images/articles/server/c/data-struct/tree/07.tree.png" alt=""></p><h2 id="树转换成二叉树" tabindex="-1">树转换成二叉树 <a class="header-anchor" href="#树转换成二叉树" aria-label="Permalink to &quot;树转换成二叉树&quot;">​</a></h2><p><code>孩子兄弟表示法</code>又称<code>二叉树表示法</code>,或<code>二叉链表表示法</code>,即以<code>二叉链表</code>作为树的存储结构,链表中结点的两个链域分别指向该结点的<code>第一个孩子结点</code>和<code>下一个兄弟结点</code>; <img src="https://raw.githubusercontent.com/matrix-johnjohn/kimo-docs/refs/heads/main/images/articles/server/c/data-struct/tree/08.tree.png" alt=""></p><h2 id="森林转二叉树" tabindex="-1">森林转二叉树 <a class="header-anchor" href="#森林转二叉树" aria-label="Permalink to &quot;森林转二叉树&quot;">​</a></h2><p><img src="https://raw.githubusercontent.com/matrix-johnjohn/kimo-docs/refs/heads/main/images/articles/server/c/data-struct/tree/09.tree.png" alt=""></p><p><img src="https://raw.githubusercontent.com/matrix-johnjohn/kimo-docs/refs/heads/main/images/articles/server/c/data-struct/tree/091.tree.png" alt=""></p><p><img src="https://raw.githubusercontent.com/matrix-johnjohn/kimo-docs/refs/heads/main/images/articles/server/c/data-struct/tree/092.tree.png" alt=""></p><h2 id="二叉树转森林" tabindex="-1">二叉树转森林 <a class="header-anchor" href="#二叉树转森林" aria-label="Permalink to &quot;二叉树转森林&quot;">​</a></h2><p><img src="https://raw.githubusercontent.com/matrix-johnjohn/kimo-docs/refs/heads/main/images/articles/server/c/data-struct/tree/092.tree.png" alt=""></p><p><img src="https://raw.githubusercontent.com/matrix-johnjohn/kimo-docs/refs/heads/main/images/articles/server/c/data-struct/tree/091.tree.png" alt=""></p><p><img src="https://raw.githubusercontent.com/matrix-johnjohn/kimo-docs/refs/heads/main/images/articles/server/c/data-struct/tree/09.tree.png" alt=""></p>',16))])}const j=s(h,[["render",u]]);export{T as __pageData,j as default};
